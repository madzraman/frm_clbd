---
title: "rmd2"
output: html_document
date: '2022-06-16'
---

# Load in data

```{r}
library(lme4)
library(survival)
library(tidyverse)
library(haven)

```

```{r}

fin2 <- integer(100*200*10)
fin3 <- integer(100*200*10)
fin4 <- integer(100*200*10)
fin5 <- integer(100*200*10)
fin6 <- integer(100*200*10)
fin7 <- integer(100*200*10)
fin8 <- integer(100*200*10)
fin9 <- integer(100*200*10)
fin10 <- integer(100*200*10)
for (zi in 1:100){
  zv2 <- rep(zi, 200*10) + 100
  zv3 <- rep(zi, 200*10) + 200
  zv4 <- rep(zi, 200*10) + 300
  zv5 <- rep(zi, 200*10) + 400
  zv6 <- rep(zi, 200*10) + 500
  zv7 <- rep(zi, 200*10) + 600
  zv8 <- rep(zi, 200*10) + 700
  zv9 <- rep(zi, 200*10) + 800
  zv10 <- rep(zi, 200*10) + 900
  fin2[((zi-1)*2000 + 1):(zi*2000)] <- zv2
  fin3[((zi-1)*2000 + 1):(zi*2000)] <- zv3
  fin4[((zi-1)*2000 + 1):(zi*2000)] <- zv4
  fin5[((zi-1)*2000 + 1):(zi*2000)] <- zv5
  fin6[((zi-1)*2000 + 1):(zi*2000)] <- zv6
  fin7[((zi-1)*2000 + 1):(zi*2000)] <- zv7
  fin8[((zi-1)*2000 + 1):(zi*2000)] <- zv8
  fin9[((zi-1)*2000 + 1):(zi*2000)] <- zv9
  fin10[((zi-1)*2000 + 1):(zi*2000)] <- zv10
}

hetero_out_100d_n04_2_2$ndat <- rep(fin2, 27)
hetero_out_100d_n04_2_3$ndat <- rep(fin3, 27)
hetero_out_100d_n04_2_4$ndat <- rep(fin4, 27)
hetero_out_100d_n04_2_5$ndat <- rep(fin5, 27)
hetero_out_100d_n04_2_6$ndat <- rep(fin6, 27)
hetero_out_100d_n04_2_7$ndat <- rep(fin7, 27)
hetero_out_100d_n04_2_8$ndat <- rep(fin8, 27)
hetero_out_100d_n04_2_9$ndat <- rep(fin9, 27)
hetero_out_100d_n04_2_10$ndat <- rep(fin10, 27)

```



```{r}
simdat <- rbind(hetero_out_100d_n04_2_1, 
                hetero_out_100d_n04_2_2, 
                hetero_out_100d_n04_2_3, 
                hetero_out_100d_n04_2_4, 
                hetero_out_100d_n04_2_5,
                hetero_out_100d_n04_2_6,
                hetero_out_100d_n04_2_7,
                hetero_out_100d_n04_2_8,
                hetero_out_100d_n04_2_9,
                hetero_out_100d_n04_2_10
                )
```



```{r}
# simdat10 <- data.frame(read_sas("10datasets.sas7bdat", NULL))
# simdat1 <- data.frame(read_sas("../data/heterogeneous/hetero_out_1subj.sas7bdat", NULL))
# simdat10 <- data.frame(read_sas("../data/heterogeneous/hetero_out_10subj10d.sas7bdat", NULL))
# simdat100 <- data.frame(read_sas("../data/heterogeneous/hetero_out_100d.sas7bdat", NULL))
# simdat100_0 <- data.frame(read_sas("../data/heterogeneous/hetero_out_100d_0.sas7bdat", NULL))
# simdat100_04 <- data.frame(read_sas("../data/heterogeneous/hetero_out_100d_pospt4.sas7bdat", NULL))


# head(simdat, 14)

```


```{r, include=FALSE}

# unique(simdat$ndats)
# 
# for (col in 18:38){
#   print(colnames(simdat)[col])
#   print(unique(simdat[,col])[1:50])
#   print("-------")
# }

# names(simdat)[16]

# sum(simdat$id == simdat$n) # these are the same column btw

```


# Define constants based on SAS data table and reduce df size

```{r}

ndats <- 1000 #simdat$ndats[1] # but really its 500
npergrp <- simdat$npergrp[1] # then 2 groups
nsubj <- simdat$nsubj[1] # so 200 subjects total, but we aren't really using/dividing the groups here
ssbetaWS <- simdat$ssbetaWS[1]
all_ssbetaBS <- c(simdat$`ssbetaBS[1]`[1], simdat$`ssbetaBS[2]`[1], simdat$`ssbetaBS[3]`[1]) # k
ntimepoints <- simdat$ntime[1]
all_REcorrs <- unique(simdat$`REcorr[j]`) # j
all_covs <- c(simdat$`cov[1]`[1], simdat$`cov[2]`[1], simdat$`cov[3]`[1]) # c

# varerr <- pi^2 / 3  # note that atan(1) = pi/4 so atan(1) * 4 = pi. varerr = (atan(1) * 4)**2 / 3
# 
# varsub <- varerr * (icc / (1-icc)) # subject variance given the icc and error variance (sigma squared v given icc and sigma squared e).
# 
# sdsub <- sqrt(varsub)

simdat_new <- simdat[,-c(1:17, 25)]
```

```{r}

m5.all_estimates_mat <- list()
m5.cov_rej_mat <- list()
for (ll in 1:3){
  m5.all_estimates_mat[[ll]] <- matrix(nrow = ndats, ncol = length(all_REcorrs)*length(all_ssbetaBS))
  m5.cov_rej_mat[[ll]] <- matrix(0, nrow = 2, ncol = length(all_REcorrs)*length(all_ssbetaBS))
}

m6.all_estimates_mat <- list()
m6.cov_rej_mat <- list()
for (ll in 1:3){
  m6.all_estimates_mat[[ll]] <- matrix(nrow = ndats, ncol = length(all_REcorrs)*length(all_ssbetaBS))
  m6.cov_rej_mat[[ll]] <- matrix(0, nrow = 2, ncol = length(all_REcorrs)*length(all_ssbetaBS))
}

m7.all_estimates_mat <- list()
m7.cov_rej_mat <- list()
for (ll in 1:3){
  m7.all_estimates_mat[[ll]] <- matrix(nrow = ndats, ncol = length(all_REcorrs)*length(all_ssbetaBS))
  m7.cov_rej_mat[[ll]] <- matrix(0, nrow = 2, ncol = length(all_REcorrs)*length(all_ssbetaBS))
}

m8.all_estimates_mat <- list()
m8.cov_rej_mat <- list()
for (ll in 1:3){
  m8.all_estimates_mat[[ll]] <- matrix(nrow = ndats, ncol = length(all_REcorrs)*length(all_ssbetaBS))
  m8.cov_rej_mat[[ll]] <- matrix(0, nrow = 2, ncol = length(all_REcorrs)*length(all_ssbetaBS))
}

```



```{r, warning = FALSE, message = FALSE}

# k, j, ndat are indicators of the loop for which ssbetaBS and which REcorr and which dataset we're on. we repeat the 9 combinations for 10 datasets each. and c represents the loop for which cov between ssBetaBS and random intercept we using

for (cc in 1:length(all_covs)){
  print('--------cc--------')
  print(cc)
  this_dfCC <- simdat_new[simdat_new$c == cc,]
  for (dd in 1:ndats){ # for each dataset
    # print(dd) 
    this_dfS <- this_dfCC[this_dfCC$ndat == dd,]
    condition_num <- 0
    for (kk in 1:length(all_ssbetaBS)){
      for (jj in 1:length(all_REcorrs)){
        condition_num <- condition_num + 1 # 1 through 9
        # print(condition_num)
        this_df <- this_dfS[(this_dfS$j == jj) & (this_dfS$k == kk),] # j is REcorr and k is ssbetaBS
        this_REcorr <- all_REcorrs[jj]
        this_ssbetaBS <- all_ssbetaBS[kk]
  
        # Heterogeneous exposure models 
        m5.out <- glmer(y ~ grp + (1 + grp|id), family=binomial, data=this_df) # heterogeneous exposure version of M1
        m6.out <- glmer(y ~ grpmean + grpdev + (1 + grp|id), family=binomial, data=this_df) # heterogeneous exposure version of M2
        m7.out <- glmer(y ~ grpdev + (1 + grp|id), family=binomial, data=this_df) # heterogeneous exposure version of M4
        m8.out <- clogit(y ~ grp + strata(id), data=this_df) # conditional logistic regression model
        
        # # M5: Heterogeneous M1 Random Intercept + Slope model assuming BS=WS effect, no BS/WS decomposition
        m5.grp.est <- summary(m5.out)$coefficients[2,1]
        m5.grp.stderr <- summary(m5.out)$coefficients[2,2]
        m5.upper <- m5.grp.est + qnorm(0.975)*m5.grp.stderr
        m5.lower <- m5.grp.est - qnorm(0.975)*m5.grp.stderr
        covers_inrange5 <- ifelse((ssbetaWS > m5.lower) & (ssbetaWS < m5.upper), 1, 0)
        reject_signif5 <- ifelse((0 < m5.lower) | (0 > m5.upper), 1, 0)
        m5.all_estimates_mat[[cc]][dd, condition_num] <- m5.grp.est
        m5.cov_rej_mat[[cc]][1, condition_num] <- m5.cov_rej_mat[[cc]][1, condition_num] + covers_inrange5 # coverage
        m5.cov_rej_mat[[cc]][2, condition_num] <- m5.cov_rej_mat[[cc]][2, condition_num] + reject_signif5 # rejection

        # # M6: Heterogeneous M2 Random Intercept + Slope model with BS/WS decomposition
        m6.grpdev.est <- summary(m6.out)$coefficients[3,1]
        m6.grpdev.stderr <- summary(m6.out)$coefficients[3,2]
        m6.upper <- m6.grpdev.est + qnorm(0.975)*m6.grpdev.stderr
        m6.lower <- m6.grpdev.est - qnorm(0.975)*m6.grpdev.stderr
        covers_inrange6 <- ifelse((ssbetaWS > m6.lower) & (ssbetaWS < m6.upper), 1, 0)
        reject_signif6 <- ifelse((0 < m6.lower) | (0 > m6.upper), 1, 0)
        m6.all_estimates_mat[[cc]][dd, condition_num] <- m6.grpdev.est
        m6.cov_rej_mat[[cc]][1, condition_num] <- m6.cov_rej_mat[[cc]][1, condition_num] + covers_inrange6 # coverage
        m6.cov_rej_mat[[cc]][2, condition_num] <- m6.cov_rej_mat[[cc]][2, condition_num] + reject_signif6 # rejection

        # # M7: Heterogeneous M4 Random Intercept + Slope model with Adaptive Centering approach (WS deviation effect only)
        m7.grpdev.est <- summary(m7.out)$coefficients[2,1]
        m7.grpdev.stderr <- summary(m7.out)$coefficients[2,2]
        m7.upper <- m7.grpdev.est + qnorm(0.975)*m7.grpdev.stderr
        m7.lower <- m7.grpdev.est - qnorm(0.975)*m7.grpdev.stderr
        covers_inrange7 <- ifelse((ssbetaWS > m7.lower) & (ssbetaWS < m7.upper), 1, 0)
        reject_signif7 <- ifelse((0 < m7.lower) | (0 > m7.upper), 1, 0)
        m7.all_estimates_mat[[cc]][dd, condition_num] <- m7.grpdev.est
        m7.cov_rej_mat[[cc]][1, condition_num] <- m7.cov_rej_mat[[cc]][1, condition_num] + covers_inrange7 # coverage
        m7.cov_rej_mat[[cc]][2, condition_num] <- m7.cov_rej_mat[[cc]][2, condition_num] + reject_signif7 # rejection

        # # M8: Conditional Logistic Regression == M3
        m8.grpdev.est <- summary(m8.out)$coefficients[1,1]
        m8.grpdev.stderr <- summary(m8.out)$coefficients[1,3]
        m8.upper <- m8.grpdev.est + qnorm(0.975)*m8.grpdev.stderr
        m8.lower <- m8.grpdev.est - qnorm(0.975)*m8.grpdev.stderr
        covers_inrange8 <- ifelse((ssbetaWS > m8.lower) & (ssbetaWS < m8.upper), 1, 0)
        reject_signif8 <- ifelse((0 < m8.lower) | (0 > m8.upper), 1, 0)
        m8.all_estimates_mat[[cc]][dd, condition_num] <- m8.grpdev.est
        m8.cov_rej_mat[[cc]][1, condition_num] <- m8.cov_rej_mat[[cc]][1, condition_num] + covers_inrange8 # coverage
        m8.cov_rej_mat[[cc]][2, condition_num] <- m8.cov_rej_mat[[cc]][2, condition_num] + reject_signif8 # rejection
      }
    }
  }
}

```

```{r}

for (lll in 1:3){
  print(all_covs[lll])
  print(colMeans(m5.all_estimates_mat[[lll]]))
}

for (lll in 1:3){
  print(all_covs[lll])
  print(colMeans(m6.all_estimates_mat[[lll]]))
}

for (lll in 1:3){
  print(all_covs[lll])
  print(colMeans(m7.all_estimates_mat[[lll]]))
}

for (lll in 1:3){
  print(all_covs[lll])
  print(colMeans(m8.all_estimates_mat[[lll]]))
}




for (lll in 1:3){
  print(all_covs[lll])
  print(m5.cov_rej_mat[[lll]]/ndats)
}
for (lll in 1:3){
  print(all_covs[lll])
  print(m6.cov_rej_mat[[lll]]/ndats)
}
for (lll in 1:3){
  print(all_covs[lll])
  print(m7.cov_rej_mat[[lll]]/ndats)
}

for (lll in 1:3){
  print(all_covs[lll])
  print(m8.cov_rej_mat[[lll]]/ndats)
}

```



